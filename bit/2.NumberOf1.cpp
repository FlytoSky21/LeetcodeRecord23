#include<iostream>
using namespace std;


int NumberOf1(int n) {
    int res=0;
    //按位遍历，从0遍历到31，因为整数通常是32位的
    for(int i=0;i<32;++i){
        //按位比较
        //使用位操作来检查整数n的第i位是否为1
        //1<<i：将1左移i位，生成一个只有第i位为1的二进制数
        //n&(1<<i)将整数n和上述生成的只有第i位为1的二进制数按位与操作，如果n的第i位为1，那么结果不会为0
        if((n&(1<<i))!=0) res++;
    }
    return res;
}


/**
 *  `while(n)` 开始一个循环，只要 `n` 不等于0，就继续执行循环。这是因为只有当 `n` 变成0时，它的二进制表示中就没有1了，循环才会停止。
 *  `n &= n - 1;` 这一行是核心部分，它使用位操作来消除 `n` 中的最低位的1。具体步骤如下：
   - `n - 1` 将 `n` 的最低位1变为0，并将低位的0都变成1。例如，如果 `n` 的二进制表示是`11010100`，那么 `n - 1` 的二进制表示是`11010011`。
   - `n & (n - 1)` 是将 `n` 与 `n - 1` 进行按位与操作，这会导致 `n` 中的最低位1变为0。继续上面的例子，`11010100 & 11010011` 的结果是`11010000`。
   - 每执行一次 `n &= n - 1;` 操作，都会消除 `n` 中的一个1。

5. 在每次执行 `n &= n - 1;` 后，`res` 的值增加1，表示找到了一个1。

6. 循环结束后，函数返回 `res`，即整数 `n` 二进制表示中1的个数。

这种算法的效率很高，因为它的循环次数等于整数 `n` 二进制表示中1的个数，而不是固定的32次。在实际应用中，特别是处理大整数时，这个算法比遍历32位的方法更快速。
*/
int NumberOf1_2(int n){
    int res=0;
    while(n){
        n&=n-1;
        res++;
    }
    return res;
}

int main(){
    int n=10;
    cout<<NumberOf1_2(n)<<endl;
    return 0;
}